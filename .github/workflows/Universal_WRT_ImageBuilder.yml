name: Universal WRT ImageBuilder

# =============================================================================
# АРХИТЕКТУРА:
#   Job 1 (setup)   → генерирует matrix устройств/вариантов
#   Job 2 (build)   → для каждой пары target+variant:
#     Фаза A: SDK → компилирует ТОЛЬКО кастомные пакеты (~15 мин)
#     Фаза B: Image Builder → собирает прошивку из официальных + кастомных пакетов (~5 мин)
#
# ВЫИГРЫШ ВО ВРЕМЕНИ:
#   Старый подход: ~90 мин (полная компиляция всего, включая Rust)
#   Новый подход:  ~20 мин (только кастомные пакеты + сборка образа)
#
# КАСТОМНЫЕ ПАКЕТЫ (компилируются через SDK, не доступны в официальных репо):
#   - luci-app-homeproxy  (immortalwrt/homeproxy)
#   - luci-app-log        (gSpotx2f/luci-app-log)
#   - youtubeUnblock + luci-app-youtubeUnblock  (Waujito/youtubeUnblock)
#   - luci-app-internet-detector (gSpotx2f/luci-app-internet-detector)
#   - luci-app-passwall2  (только вариант passwall)
#   - luci-app-xray       (только вариант xray)
#   - facinstall          (только устройство ax59u)
#   - fancontrol          (только устройство slateax)
#   - zapret              (если включен в конфиге)
#
# ОГРАНИЧЕНИЯ по сравнению с полной сборкой:
#   - kmod-nft-fullcone: доступен только в ImmortalWrt, для OpenWrt пропускается
#   - Патчи ядра: Image Builder использует официальное ядро, кастомные патчи ядра невозможны
#   - kmod-r8125 vs kmod-r8125-rss: для R5S/R6S указываем правильный через PACKAGES список
# =============================================================================

on:
  workflow_dispatch:
    inputs:
      target:
        description: 'Target Device'
        required: true
        default: 'combo'
        type: choice
        options:
          - combo
          - rb5009
          - nanopi-r6s
          - nanopi-r5s
          - slateax
          - ax59u
          - brume2
          - all

      source:
        description: 'Source Code'
        required: true
        default: 'openwrt'
        type: choice
        options:
          - immortalwrt
          - openwrt

      branch:
        description: 'Branch'
        required: true
        default: 'openwrt-25.12'
        type: choice
        options:
          - openwrt-24.10
          - openwrt-25.12

      variant:
        description: 'Build Variant'
        required: true
        default: 'standard'
        type: choice
        options:
          - standard
          - minimal
          - clear
          - switch
          - crystal_clear
          - passwall
          - v2raya
          - xray

      exclude_keywords:
        description: 'Exclude Packages (space-separated keywords)'
        required: false
        default: ''
        type: string

env:
  CONFIG_FILE: ./config/WRT.config
  TZ: Europe/Moscow
  WORKDIR: /workdir

jobs:
  # ===========================================================================
  # JOB 1: SETUP — генерация матрицы (идентично оригиналу)
  # ===========================================================================
  setup:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - id: set-matrix
        run: |
          INPUT_TARGET="${{ inputs.target }}"
          INPUT_VARIANT="${{ inputs.variant }}"

          if [ "$INPUT_TARGET" == "combo" ]; then
            echo ">>> Generating COMBO matrix..."
            json='{"include":[
              {"target":"nanopi-r5s","variant":"minimal"},
              {"target":"nanopi-r6s","variant":"minimal"},
              {"target":"rb5009","variant":"clear"},
              {"target":"rb5009","variant":"switch"}
            ]}'
          else
            targets="nanopi-r6s nanopi-r5s rb5009 slateax ax59u brume2"
            if [ "$INPUT_TARGET" == "all" ]; then
              selected=$targets
            else
              selected="$INPUT_TARGET"
            fi
            json_parts=""
            for t in $selected; do
              [ -n "$json_parts" ] && json_parts="$json_parts,"
              json_parts="$json_parts{\"target\":\"$t\",\"variant\":\"$INPUT_VARIANT\"}"
            done
            json="{\"include\":[$json_parts]}"
          fi

          echo "=========================================="
          echo "       [SETUP SUMMARY]"
          echo "Mode: $INPUT_TARGET"
          echo "Generated Matrix: $json"
          echo "=========================================="
          echo "matrix<<EOF" >> $GITHUB_OUTPUT
          echo "$json" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  # ===========================================================================
  # JOB 2: BUILD — сборка прошивки через SDK + Image Builder
  # ===========================================================================
  build:
    needs: setup
    runs-on: ubuntu-22.04
    permissions:
      contents: write
      actions: write

    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.setup.outputs.matrix) }}

    name: ${{ inputs.source }} ${{ inputs.branch }} [${{ matrix.variant }}] - ${{ matrix.target }}

    steps:

    # -------------------------------------------------------------------------
    # 1. Освобождение места на диске
    # -------------------------------------------------------------------------
    - name: Free disk space
      run: |
        echo ">>> Initial disk space:"
        df -h
        sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc \
                    /opt/hostedtoolcache /usr/lib/jvm /usr/share/swift \
                    /usr/local/.ghcup /usr/local/share/powershell \
                    /usr/local/share/chromium /usr/local/share/boost \
                    "$AGENT_TOOLSDIRECTORY"
        sudo docker image prune --all --force || true
        sudo apt-get -y purge "azure*" "dotnet*" "ghc*" "llvm*" "mono*" \
                              "android*" "google*" "firefox*" "powershell*" \
                              "mysql*" "php*" || true
        sudo apt-get autoremove -y && sudo apt-get clean
        echo ">>> Final disk space:"
        df -h

    # -------------------------------------------------------------------------
    # 2. Checkout репозитория с конфигами и скриптами
    # -------------------------------------------------------------------------
    - name: Checkout
      uses: actions/checkout@main

    # -------------------------------------------------------------------------
    # 3. Права на файлы
    # -------------------------------------------------------------------------
    - name: Set permissions
      run: |
        [ -d "./files/usr/bin" ] && \
          find ./files/usr/bin -maxdepth 1 -type f -exec chmod 755 {} + || true
        [ -d "./files/etc/uci-defaults" ] && \
          find ./files/etc/uci-defaults -maxdepth 1 -type f -exec chmod 755 {} + || true
        echo "Permissions set."

    # -------------------------------------------------------------------------
    # 4. Настройка переменных сборки (автодетект тега/коммита, устройство)
    # -------------------------------------------------------------------------
    - name: Configure Build Variables
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # --- Источник и API ---
        if [ "${{ inputs.source }}" == "immortalwrt" ]; then
          API_REPO="immortalwrt/immortalwrt"
          SOURCE_NAME="immortalwrt"
        else
          API_REPO="openwrt/openwrt"
          SOURCE_NAME="openwrt"
        fi
        echo "SOURCE_NAME=$SOURCE_NAME" >> $GITHUB_ENV

        # --- Ветка и релиз ---
        INPUT_BRANCH="${{ inputs.branch }}"
        VAR_BRANCH="$INPUT_BRANCH"
        VAR_TARGET_RELEASE=""
        VAR_COMMIT_HASH=""

        if [ "$INPUT_BRANCH" == "master" ]; then
          [ "${{ inputs.source }}" == "openwrt" ] && VAR_BRANCH="main"
          VAR_TARGET_RELEASE="snapshots"
        else
          TAG_PREFIX="v${INPUT_BRANCH#openwrt-}"
          echo ">>> Searching for latest tag: '$TAG_PREFIX' in $API_REPO..."
          TAG_JSON=$(curl -sf -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/$API_REPO/tags" | \
            jq --arg prefix "$TAG_PREFIX" \
               '[.[] | select(.name | startswith($prefix))] | first' 2>/dev/null || echo "null")

          if [ "$TAG_JSON" != "null" ] && [ -n "$TAG_JSON" ]; then
            TAG_NAME=$(echo "$TAG_JSON" | jq -r '.name')
            TAG_COMMIT=$(echo "$TAG_JSON" | jq -r '.commit.sha')
            CLEAN_VER="${TAG_NAME#v}"
            VAR_TARGET_RELEASE="releases/$CLEAN_VER"
            VAR_COMMIT_HASH="$TAG_COMMIT"
            echo ">>> Found tag: $TAG_NAME (commit: $TAG_COMMIT)"

            # ImmortalWrt: если папки релиза нет → SNAPSHOT
            if [ "${{ inputs.source }}" == "immortalwrt" ]; then
              HTTP_CODE=$(curl -o /dev/null -sf -w "%{http_code}" \
                "https://downloads.immortalwrt.org/$VAR_TARGET_RELEASE/targets/")
              if [ "$HTTP_CODE" != "200" ]; then
                echo ">>> ImmortalWrt release folder missing → using SNAPSHOT"
                VAR_TARGET_RELEASE="releases/${INPUT_BRANCH#openwrt-}-SNAPSHOT"
              fi
            fi
          else
            echo ">>> WARNING: tag not found, using fallback"
          fi

          # Фолбэк
          if [ -z "$VAR_TARGET_RELEASE" ]; then
            if [[ "$INPUT_BRANCH" == *"25.12"* ]]; then
              VAR_TARGET_RELEASE="releases/25.12.0-rc5"
            elif [[ "$INPUT_BRANCH" == *"24.10"* ]]; then
              if [ "${{ inputs.source }}" == "immortalwrt" ]; then
                VAR_TARGET_RELEASE="releases/24.10-SNAPSHOT"
              else
                VAR_TARGET_RELEASE="releases/24.10.0"
              fi
            fi
          fi
        fi

        echo "REPO_BRANCH=$VAR_BRANCH" >> $GITHUB_ENV
        echo "TARGET_RELEASE=$VAR_TARGET_RELEASE" >> $GITHUB_ENV
        echo "AUTO_COMMIT_HASH=$VAR_COMMIT_HASH" >> $GITHUB_ENV

        # --- Домен загрузок ---
        if [ "${{ inputs.source }}" == "immortalwrt" ]; then
          # Используем зеркало (официальный downloads.immortalwrt.org нестабилен)
          DOMAIN="immortalwrt.kyarucloud.moe"
          DOMAIN_FALLBACK="downloads.immortalwrt.org"
        else
          DOMAIN="downloads.openwrt.org"
          DOMAIN_FALLBACK="downloads.openwrt.org"
        fi
        echo "DOMAIN=$DOMAIN" >> $GITHUB_ENV
        echo "DOMAIN_FALLBACK=$DOMAIN_FALLBACK" >> $GITHUB_ENV

        # --- Конфиг устройства ---
        source ./config/conf/${{ matrix.target }}
        echo "TARGET_NAME=${TARGET_NAME}" >> $GITHUB_ENV
        echo "KERNEL_PATH=${KERNEL_PATH}" >> $GITHUB_ENV
        echo "DEVICE_CONFIG_COMMANDS<<EOF" >> $GITHUB_ENV
        echo "${DEVICE_CONFIG_COMMANDS}" >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV

        echo "=========================================="
        echo "       [VARIABLES SUMMARY]"
        echo "Source         : ${{ inputs.source }}"
        echo "Branch         : $VAR_BRANCH"
        echo "Target Release : $VAR_TARGET_RELEASE"
        echo "Tag Commit     : $VAR_COMMIT_HASH"
        echo "Device         : ${{ matrix.target }} ($TARGET_NAME)"
        echo "Variant        : ${{ matrix.variant }}"
        echo "KERNEL_PATH    : $KERNEL_PATH"
        echo "Download Domain: $DOMAIN"
        echo "=========================================="

    # -------------------------------------------------------------------------
    # 5. Установка зависимостей
    # Image Builder/SDK нужно гораздо меньше пакетов чем полная сборка
    # -------------------------------------------------------------------------
    - name: Init Env
      env: { DEBIAN_FRONTEND: noninteractive }
      run: |
        sudo -E apt-get -qq update
        sudo -E apt-get -qq install \
          build-essential clang flex bison g++ gawk gcc-multilib g++-multilib \
          gettext git libncurses-dev libssl-dev python3-setuptools rsync unzip \
          zlib1g-dev file wget curl jq aria2 libfuse-dev \
          python3-pyelftools python3-distutils qemu-utils zstd
        sudo timedatectl set-timezone "$TZ"
        sudo mkdir -p $WORKDIR && sudo chown $USER:$GROUPS $WORKDIR
        mkdir -p $WORKDIR/files $WORKDIR/custom-packages

    # -------------------------------------------------------------------------
    # 6. Скачивание AdGuardHome (бинарник, не пакет)
    # Условие: не для switch/clear/crystal_clear
    # -------------------------------------------------------------------------
    - name: Download AdGuardHome
      if: |
        matrix.variant != 'switch' &&
        matrix.variant != 'clear' &&
        matrix.variant != 'crystal_clear'
      run: |
        AGH_URL="https://github.com/AdguardTeam/AdGuardHome/releases/latest/download/AdGuardHome_linux_arm64.tar.gz"
        echo ">>> Downloading AdGuardHome..."
        curl -L -o /tmp/AGH.tar.gz "$AGH_URL"
        tar -xzf /tmp/AGH.tar.gz -C /tmp/
        mkdir -p ./files/usr/bin
        cp /tmp/AdGuardHome/AdGuardHome ./files/usr/bin/
        chmod 755 ./files/usr/bin/AdGuardHome
        rm -rf /tmp/AGH.tar.gz /tmp/AdGuardHome
        echo ">>> AdGuardHome downloaded: $(./files/usr/bin/AdGuardHome --version 2>&1 | head -1)"

    # -------------------------------------------------------------------------
    # 7. Скачивание Sing-box (бинарник, не пакет)
    # Условие: только для standard/minimal (homeproxy нужен свежий бинарник)
    # -------------------------------------------------------------------------
    - name: Download Sing-box
      if: |
        matrix.variant != 'switch' &&
        matrix.variant != 'clear' &&
        matrix.variant != 'crystal_clear' &&
        matrix.variant != 'passwall' &&
        matrix.variant != 'v2raya' &&
        matrix.variant != 'xray'
      run: |
        SB_URL=$(curl -sf "https://api.github.com/repos/SagerNet/sing-box/releases/latest" | \
          jq -r '.assets[] | select(.name | test("linux-arm64\\.tar\\.gz$")) | .browser_download_url' | \
          head -1)
        echo ">>> Downloading sing-box from: $SB_URL"
        curl -L -o /tmp/sb.tar.gz "$SB_URL"
        tar -xzf /tmp/sb.tar.gz -C /tmp/
        mkdir -p ./files/usr/bin
        cp /tmp/sing-box-*/sing-box ./files/usr/bin/
        chmod 755 ./files/usr/bin/sing-box
        rm -rf /tmp/sb.tar.gz /tmp/sing-box-*
        SB_VER=$(./files/usr/bin/sing-box version 2>/dev/null | grep -oP 'v[\d.]+' | head -1)
        echo ">>> Sing-box downloaded: $SB_VER"

    # -------------------------------------------------------------------------
    # 8. Скачивание и распаковка Image Builder
    # -------------------------------------------------------------------------
    - name: Download Image Builder
      working-directory: ${{ env.WORKDIR }}
      run: |
        # Формируем URL к директории с файлами для нашего target
        IB_BASE_URL="https://${DOMAIN}/${TARGET_RELEASE}/targets/${KERNEL_PATH}"
        echo ">>> Looking for Image Builder at: $IB_BASE_URL"

        # Получаем имя файла Image Builder из листинга директории
        IB_FILE=$(curl -sf "$IB_BASE_URL/" | \
          grep -oP '(?<=href=")[^"]*imagebuilder[^"]*\.tar\.(?:zst|xz|bz2)' | \
          head -1)

        if [ -z "$IB_FILE" ]; then
          echo ">>> Primary domain failed, trying fallback: $DOMAIN_FALLBACK"
          IB_BASE_URL="https://${DOMAIN_FALLBACK}/${TARGET_RELEASE}/targets/${KERNEL_PATH}"
          IB_FILE=$(curl -sf "$IB_BASE_URL/" | \
            grep -oP '(?<=href=")[^"]*imagebuilder[^"]*\.tar\.(?:zst|xz|bz2)' | \
            head -1)
        fi

        if [ -z "$IB_FILE" ]; then
          echo ">>> ERROR: Image Builder not found!"
          echo ">>> URL tried: $IB_BASE_URL/"
          curl -sf "$IB_BASE_URL/" | grep href || true
          exit 1
        fi

        IB_URL="${IB_BASE_URL}/${IB_FILE}"
        echo ">>> Downloading Image Builder: $IB_URL"
        curl -L --progress-bar -o "imagebuilder.tar.zst" "$IB_URL"

        # Распаковка (zst, xz, bz2 - определяем по расширению)
        case "$IB_FILE" in
          *.tar.zst) tar --zstd -xf imagebuilder.tar.zst ;;
          *.tar.xz)  tar -xJf   imagebuilder.tar.zst ;;
          *.tar.bz2) tar -xjf   imagebuilder.tar.zst ;;
        esac
        rm -f imagebuilder.tar.zst

        # Находим папку IB (имя зависит от версии/источника)
        IB_DIR=$(ls -d */  2>/dev/null | grep -E "(openwrt|immortalwrt)-imagebuilder" | head -1 | tr -d '/')
        if [ -z "$IB_DIR" ]; then
          echo ">>> ERROR: Could not find Image Builder directory!"
          ls -la
          exit 1
        fi

        echo "IB_DIR=$WORKDIR/$IB_DIR" >> $GITHUB_ENV
        echo ">>> Image Builder ready: $IB_DIR"
        ls "$IB_DIR/"

    # -------------------------------------------------------------------------
    # 9. Скачивание и распаковка SDK
    # SDK компилирует кастомные пакеты без сборки всего toolchain (~15 мин экономии)
    # -------------------------------------------------------------------------
    - name: Download SDK
      working-directory: ${{ env.WORKDIR }}
      run: |
        SDK_BASE_URL="https://${DOMAIN}/${TARGET_RELEASE}/targets/${KERNEL_PATH}"
        echo ">>> Looking for SDK at: $SDK_BASE_URL"

        SDK_FILE=$(curl -sf "$SDK_BASE_URL/" | \
          grep -oP '(?<=href=")[^"]*sdk[^"]*\.tar\.(?:zst|xz|bz2)' | \
          head -1)

        if [ -z "$SDK_FILE" ]; then
          echo ">>> Primary domain failed, trying fallback..."
          SDK_BASE_URL="https://${DOMAIN_FALLBACK}/${TARGET_RELEASE}/targets/${KERNEL_PATH}"
          SDK_FILE=$(curl -sf "$SDK_BASE_URL/" | \
            grep -oP '(?<=href=")[^"]*sdk[^"]*\.tar\.(?:zst|xz|bz2)' | \
            head -1)
        fi

        if [ -z "$SDK_FILE" ]; then
          echo ">>> ERROR: SDK not found!"
          exit 1
        fi

        SDK_URL="${SDK_BASE_URL}/${SDK_FILE}"
        echo ">>> Downloading SDK: $SDK_URL"
        curl -L --progress-bar -o "sdk.tar.zst" "$SDK_URL"

        case "$SDK_FILE" in
          *.tar.zst) tar --zstd -xf sdk.tar.zst ;;
          *.tar.xz)  tar -xJf   sdk.tar.zst ;;
          *.tar.bz2) tar -xjf   sdk.tar.zst ;;
        esac
        rm -f sdk.tar.zst

        SDK_DIR=$(ls -d */ 2>/dev/null | grep -E "(openwrt|immortalwrt)-sdk" | head -1 | tr -d '/')
        if [ -z "$SDK_DIR" ]; then
          echo ">>> ERROR: Could not find SDK directory!"
          ls -la
          exit 1
        fi

        echo "SDK_DIR=$WORKDIR/$SDK_DIR" >> $GITHUB_ENV
        echo ">>> SDK ready: $SDK_DIR"

    # -------------------------------------------------------------------------
    # 10. Компиляция кастомных пакетов через SDK
    # Компилируем ТОЛЬКО то, чего нет в официальных репозиториях
    # -------------------------------------------------------------------------
    - name: Compile Custom Packages (SDK)
      run: |
        cd "$SDK_DIR"
        VARIANT="${{ matrix.variant }}"
        DEVICE="${{ matrix.target }}"

        echo "=========================================="
        echo ">>> Setting up SDK feeds for: $VARIANT / $DEVICE"
        echo "=========================================="

        # --- Исправление зеркал (503 ошибки от git.openwrt.org) ---
        sed -i 's|https://git.openwrt.org/feed/packages.git|https://github.com/openwrt/packages.git|g' feeds.conf.default
        sed -i 's|https://git.openwrt.org/project/luci.git|https://github.com/openwrt/luci.git|g' feeds.conf.default
        sed -i 's|https://git.openwrt.org/feed/routing.git|https://github.com/openwrt/routing.git|g' feeds.conf.default
        sed -i 's|https://git.openwrt.org/feed/telephony.git|https://github.com/openwrt/telephony.git|g' feeds.conf.default

        # --- Добавление кастомных фидов ---
        echo "src-git youtubeUnblock https://github.com/Waujito/youtubeUnblock.git;openwrt" >> feeds.conf.default
        echo "src-git internetdetector https://github.com/gSpotx2f/luci-app-internet-detector.git" >> feeds.conf.default

        # Вариант-специфичные фиды
        if [ "$VARIANT" == "passwall" ]; then
          echo "src-git passwall2 https://github.com/Openwrt-Passwall/openwrt-passwall2.git" >> feeds.conf.default
          echo "src-git passwall_packages https://github.com/Openwrt-Passwall/openwrt-passwall-packages.git;main" >> feeds.conf.default
        elif [ "$VARIANT" == "xray" ]; then
          echo "src-git luciappxray https://github.com/yichya/luci-app-xray.git" >> feeds.conf.default
        fi

        # Slateax: fancontrol
        if [ "$DEVICE" == "slateax" ]; then
          echo "src-git fancontrol https://github.com/JiaY-shi/fancontrol.git" >> feeds.conf.default
        fi

        # --- Клонирование прямых пакетов (не в фидах) ---
        # Log viewer
        mkdir -p package/luci-app-log-viewer
        git clone --depth=1 -b master \
          https://github.com/gSpotx2f/luci-app-log.git \
          package/luci-app-log-viewer/

        # HomeProxy (только для вариантов, которые его используют)
        if [[ "$VARIANT" != "clear" && "$VARIANT" != "crystal_clear" && \
              "$VARIANT" != "switch" && "$VARIANT" != "passwall" && \
              "$VARIANT" != "xray" && "$VARIANT" != "v2raya" ]]; then
          # Только для Official OpenWrt (в ImmortalWrt homeproxy уже в фидах)
          if [[ "$SOURCE_NAME" == "openwrt" ]]; then
            mkdir -p package/luci-app-homeproxy
            git clone --depth=1 -b master \
              https://github.com/immortalwrt/homeproxy.git \
              package/luci-app-homeproxy/
            echo ">>> HomeProxy cloned"
          fi
        fi

        # facinstall (только ax59u)
        if [ "$DEVICE" == "ax59u" ]; then
          mkdir -p package/facinstall
          git clone --depth=1 -b main \
            https://github.com/openwrt-xiaomi/facinstall.git \
            package/facinstall/
          echo ">>> facinstall cloned for ax59u"
        fi

        # zapret (если включен в конфиге)
        if grep -q "^CONFIG_PACKAGE_zapret=y" $GITHUB_WORKSPACE/$CONFIG_FILE 2>/dev/null; then
          mkdir -p package/zapret-openwrt
          git clone --depth=1 -b master \
            https://github.com/remittor/zapret-openwrt.git \
            package/zapret-openwrt/
          echo ">>> zapret cloned"
        fi

        # --- Обновление и установка фидов ---
        ./scripts/feeds update -a
        ./scripts/feeds install -a

        # --- Повторная установка (для локальных пакетов) ---
        ./scripts/feeds install -a

        echo "=========================================="
        echo ">>> Compiling custom packages..."
        echo "=========================================="

        # Функция для компиляции пакета с поиском правильного пути в SDK
        compile_pkg() {
          local PKG_NAME="$1"
          # Ищем пакет в package/feeds/ и в package/
          local PKG_PATH=$(find package/feeds -maxdepth 2 -name "$PKG_NAME" -type d 2>/dev/null | head -1)
          [ -z "$PKG_PATH" ] && PKG_PATH=$(find package -maxdepth 2 -name "$PKG_NAME" -type d 2>/dev/null | head -1)
          if [ -z "$PKG_PATH" ]; then
            echo ">>> WARN: Package directory not found for: $PKG_NAME — skipping"
            return 0
          fi
          echo ">>> Compiling: $PKG_NAME (path: $PKG_PATH)"
          if make "$PKG_PATH/compile" V=s -j$(nproc) 2>&1 | tail -3; then
            echo ">>> OK: $PKG_NAME"
          else
            echo ">>> WARN: $PKG_NAME compilation failed, trying single-thread..."
            make "$PKG_PATH/compile" V=s -j1 2>&1 | tail -20 || \
              echo ">>> WARN: $PKG_NAME single-thread also failed, skipping"
          fi
        }

        # Общие кастомные пакеты (для большинства вариантов)
        if [[ "$VARIANT" != "switch" && "$VARIANT" != "crystal_clear" ]]; then
          compile_pkg "youtubeUnblock"
          compile_pkg "luci-app-youtubeUnblock"
          compile_pkg "luci-app-internet-detector"
          compile_pkg "luci-app-log"
        fi

        # HomeProxy (standard/minimal для OpenWrt)
        if [[ "$VARIANT" != "clear" && "$VARIANT" != "crystal_clear" && \
              "$VARIANT" != "switch" && "$VARIANT" != "passwall" && \
              "$VARIANT" != "xray" && "$VARIANT" != "v2raya" && \
              "$SOURCE_NAME" == "openwrt" ]]; then
          compile_pkg "luci-app-homeproxy"
        fi

        # Passwall2
        if [ "$VARIANT" == "passwall" ]; then
          compile_pkg "luci-app-passwall2"
        fi

        # Xray app
        if [ "$VARIANT" == "xray" ]; then
          compile_pkg "luci-app-xray"
        fi

        # facinstall (ax59u)
        if [ "$DEVICE" == "ax59u" ]; then
          compile_pkg "facinstall"
        fi

        # fancontrol (slateax)
        if [ "$DEVICE" == "slateax" ]; then
          compile_pkg "luci-app-fancontrol-psu"
        fi

        # zapret
        if grep -q "^CONFIG_PACKAGE_zapret=y" $GITHUB_WORKSPACE/$CONFIG_FILE 2>/dev/null; then
          compile_pkg "zapret"
        fi

        # --- Сбор всех скомпилированных .apk/.ipk ---
        echo ">>> Collecting compiled packages..."
        mkdir -p $WORKDIR/custom-packages
        # SDK складывает пакеты в bin/packages/<arch>/
        find bin/packages -name "*.apk" 2>/dev/null -exec cp {} $WORKDIR/custom-packages/ \; || true
        find bin/packages -name "*.ipk" 2>/dev/null -exec cp {} $WORKDIR/custom-packages/ \; || true

        PKG_COUNT=$(ls $WORKDIR/custom-packages/*.apk $WORKDIR/custom-packages/*.ipk 2>/dev/null | wc -l)
        echo ">>> Compiled and collected: $PKG_COUNT packages"
        ls -lh $WORKDIR/custom-packages/ | head -30

    # -------------------------------------------------------------------------
    # 11. Подготовка директории files/
    # Копируем бинарники, uci-defaults и все overlay-файлы
    # -------------------------------------------------------------------------
    - name: Prepare Files Overlay
      run: |
        VARIANT="${{ matrix.variant }}"
        DEVICE="${{ matrix.target }}"
        FILES_DIR="$WORKDIR/files"
        mkdir -p "$FILES_DIR"

        # Копируем overlay-файлы из репозитория (включая uci-defaults, etc/config и т.д.)
        if [ -d "$GITHUB_WORKSPACE/files" ]; then
          cp -r "$GITHUB_WORKSPACE/files/." "$FILES_DIR/"
          echo ">>> Copied overlay files from repo"
        fi

        # Бинарники AGH и sing-box (уже скачаны в шагах 6-7)
        if [ -d "$GITHUB_WORKSPACE/files/usr/bin" ]; then
          cp -r "$GITHUB_WORKSPACE/files/usr/bin/." "$FILES_DIR/usr/bin/" 2>/dev/null || true
        fi

        # Записываем дату сборки в overlay
        mkdir -p "$FILES_DIR/etc"
        date +'%Y-%m-%d' > "$FILES_DIR/etc/build_date"
        echo "$VARIANT" > "$FILES_DIR/etc/build_variant"
        echo ">>> build_date: $(cat $FILES_DIR/etc/build_date)"
        echo ">>> build_variant: $VARIANT"

        # Устанавливаем права на uci-defaults
        [ -d "$FILES_DIR/etc/uci-defaults" ] && \
          find "$FILES_DIR/etc/uci-defaults" -type f -exec chmod 755 {} + || true

        echo "=========================================="
        echo ">>> FILES/ overlay contents:"
        find "$FILES_DIR" -type f | sort
        echo "=========================================="

    # -------------------------------------------------------------------------
    # 12. Сборка прошивки через Image Builder
    # -------------------------------------------------------------------------
    - name: Build Image
      run: |
        cd "$IB_DIR"
        VARIANT="${{ matrix.variant }}"
        DEVICE="${{ matrix.target }}"

        echo "=========================================="
        echo ">>> Starting Image Builder for: $DEVICE [$VARIANT]"
        echo "=========================================="

        # --- Определяем пакетный менеджер (APK или OPKG) ---
        if [ -f "packages/opkg-utils" ] || ls repositories.d/*.conf 2>/dev/null | head -1 | xargs grep -q "\.ipk" 2>/dev/null; then
          PKG_MANAGER="opkg"
        else
          PKG_MANAGER="apk"
        fi
        echo ">>> Package manager: $PKG_MANAGER"

        # --- Интеграция кастомных пакетов в Image Builder ---
        # Подход: копируем .apk/.ipk в директорию packages/ внутри IB,
        # затем запускаем `make package_index` — это пересобирает индекс репо.
        # Это официальный поддерживаемый метод для IB (документирован в OpenWrt wiki).
        PKG_COPIED=0

        # Определяем целевую папку пакетов в IB (зависит от архитектуры)
        # Image Builder хранит пакеты в packages/<arch>/ или packages/
        IB_PKG_DIR=$(ls -d "$IB_DIR"/packages/*/base 2>/dev/null | head -1 | xargs dirname 2>/dev/null || echo "")
        [ -z "$IB_PKG_DIR" ] && IB_PKG_DIR=$(ls -d "$IB_DIR"/packages/* 2>/dev/null | head -1 || echo "$IB_DIR/packages")
        [ -z "$IB_PKG_DIR" ] && IB_PKG_DIR="$IB_DIR/packages"
        mkdir -p "$IB_PKG_DIR"

        if [ "$PKG_MANAGER" == "apk" ]; then
          CUSTOM_COUNT=$(find $WORKDIR/custom-packages -name "*.apk" 2>/dev/null | wc -l)
          if [ "$CUSTOM_COUNT" -gt 0 ]; then
            find $WORKDIR/custom-packages -name "*.apk" -exec cp {} "$IB_PKG_DIR/" \;
            PKG_COPIED=$CUSTOM_COUNT
          fi
        else
          CUSTOM_COUNT=$(find $WORKDIR/custom-packages -name "*.ipk" 2>/dev/null | wc -l)
          if [ "$CUSTOM_COUNT" -gt 0 ]; then
            find $WORKDIR/custom-packages -name "*.ipk" -exec cp {} "$IB_PKG_DIR/" \;
            PKG_COPIED=$CUSTOM_COUNT
          fi
        fi

        echo ">>> Copied $PKG_COPIED custom packages to: $IB_PKG_DIR"

        # Пересобираем индекс пакетов (включает теперь и кастомные)
        if [ "$PKG_COPIED" -gt 0 ]; then
          echo ">>> Rebuilding package index..."
          make package_index V=s 2>&1 | tail -10 || \
            echo ">>> WARN: package_index rebuild failed (will try to continue)"
        fi

        # --- Формирование списка пакетов из WRT.config ---
        echo ">>> Building package list from WRT.config..."

        # Базовый список из конфига (только явно включенные =y)
        # Исключаем метапакеты ядра — они не устанавливаются в IB явно
        BASE_PKGS=$(grep "^CONFIG_PACKAGE_.*=y" $GITHUB_WORKSPACE/$CONFIG_FILE | \
          sed 's/^CONFIG_PACKAGE_//; s/=y$//' | \
          grep -v "^kernel$\|^base-files$\|^libc$\|^libgcc$\|^busybox$\|^procd$\|^fwtool$\|^ubox$\|^ubus$\|^ubusd$\|^urandom-seed$" | \
          tr '\n' ' ')

        # Явно отключённые пакеты → добавляем с минус-префиксом.
        # В Image Builder "-pkg" исключает пакет даже если он тянется как зависимость.
        # Полезно для пакетов типа dnsmasq (у нас dnsmasq-full), ppp (если не нужен) и т.д.
        DISABLED_PKGS=$(grep "^CONFIG_PACKAGE_.*=n" $GITHUB_WORKSPACE/$CONFIG_FILE | \
          sed 's/^CONFIG_PACKAGE_//; s/=n$//' | \
          awk '{print "-"$0}' | \
          tr '\n' ' ')

        # --- Для OpenWrt убираем ImmortalWrt-специфичные пакеты ---
        if [ "$SOURCE_NAME" == "openwrt" ]; then
          BASE_PKGS=$(echo "$BASE_PKGS" | sed 's/\bkmod-nft-fullcone\b//g')
          echo ">>> Removed kmod-nft-fullcone (ImmortalWrt only)"
        fi

        # --- Device-specific package adjustments ---
        DEVICE_PKGS=""
        case "$DEVICE" in
          nanopi-r5s|nanopi-r6s)
            # RSS-версия r8125 для официального OpenWrt (поддержка многопоточности)
            if [ "$SOURCE_NAME" == "openwrt" ]; then
              BASE_PKGS=$(echo "$BASE_PKGS" | sed 's/\bkmod-r8125\b//g')
              DEVICE_PKGS="kmod-r8125-rss"
            fi
            DEVICE_PKGS="$DEVICE_PKGS losetup resize2fs"
            ;;
          rb5009)
            DEVICE_PKGS="losetup resize2fs"
            ;;
          slateax)
            DEVICE_PKGS="kmod-hwmon-gsc kmod-leds-gpio losetup resize2fs"
            ;;
          ax59u)
            # Для ax59u убираем тяжелые GNU утилиты (нет места)
            for pkg in coreutils coreutils-base64 coreutils-cat coreutils-chmod coreutils-chown \
                        coreutils-cp coreutils-cut coreutils-date coreutils-df coreutils-du \
                        coreutils-expand coreutils-head coreutils-ls coreutils-md5sum \
                        coreutils-mkdir coreutils-mv coreutils-nohup coreutils-numfmt \
                        coreutils-paste coreutils-rm coreutils-sha256sum coreutils-sleep \
                        coreutils-sort coreutils-stat coreutils-strings coreutils-tail \
                        coreutils-timeout coreutils-touch coreutils-tr coreutils-unexpand \
                        coreutils-uniq coreutils-wc; do
              BASE_PKGS=$(echo "$BASE_PKGS" | sed "s/\b$pkg\b//g")
            done
            DEVICE_PKGS="losetup resize2fs"
            ;;
          brume2)
            # GL-MT2500 ограниченная flash - убираем тяжелые пакеты
            for pkg in coreutils pciutils usbutils lm-sensors sysstat; do
              BASE_PKGS=$(echo "$BASE_PKGS" | sed "s/\b$pkg\b//g")
            done
            ;;
        esac

        # --- Variant-specific package overrides ---
        VARIANT_REMOVE=""
        VARIANT_ADD=""

        case "$VARIANT" in
          standard)
            # Всё по умолчанию + уже скачан AGH бинарник + homeproxy
            VARIANT_ADD="adguardhome"
            ;;
          minimal)
            # Как standard, но без SQM
            VARIANT_ADD="adguardhome"
            VARIANT_REMOVE="luci-app-sqm sqm-scripts"
            ;;
          passwall)
            # Убираем homeproxy/sing-box, добавляем passwall2
            VARIANT_REMOVE="luci-app-homeproxy sing-box adguardhome luci-app-adguardhome"
            VARIANT_ADD="luci-app-passwall2 xray-core v2ray-geodata geoview v2ray-plugin"
            # Уберём shadowsocks-зависимости (нам не нужны)
            BASE_PKGS=$(echo "$BASE_PKGS" | grep -v -i "shadowsocks" | tr '\n' ' ')
            ;;
          v2raya)
            VARIANT_REMOVE="luci-app-homeproxy sing-box adguardhome luci-app-adguardhome"
            VARIANT_ADD="luci-app-v2raya v2rayA v2ray-geodata xray-core"
            ;;
          xray)
            VARIANT_REMOVE="luci-app-homeproxy sing-box adguardhome luci-app-adguardhome"
            VARIANT_ADD="luci-app-xray xray-core v2ray-geodata geoview"
            ;;
          clear)
            # Убираем прокси-пакеты, сохраняем базовый функционал
            VARIANT_REMOVE="luci-app-homeproxy sing-box luci-app-youtubeUnblock youtubeUnblock \
                             luci-app-internet-detector internet-detector \
                             luci-app-sqm sqm-scripts adguardhome luci-app-adguardhome"
            ;;
          crystal_clear)
            # Минималистичный вариант
            VARIANT_REMOVE="luci-app-homeproxy sing-box luci-app-youtubeUnblock youtubeUnblock \
                             luci-app-internet-detector internet-detector luci-app-sqm \
                             sqm-scripts adguardhome luci-app-adguardhome lm-sensors sysstat \
                             pciutils usbutils bsdtar mtr-json tcpdump coreutils \
                             coreutils-base64 coreutils-cat coreutils-chmod coreutils-chown \
                             coreutils-cp coreutils-cut coreutils-date coreutils-df"
            ;;
          switch)
            # Только сеть + базовый веб-интерфейс
            VARIANT_REMOVE="luci-app-homeproxy sing-box luci-app-youtubeUnblock youtubeUnblock \
                             luci-app-internet-detector internet-detector luci-app-sqm \
                             sqm-scripts adguardhome luci-app-adguardhome lm-sensors sysstat \
                             luci-app-commands luci-app-filemanager pciutils usbutils \
                             bsdtar mtr-json tcpdump"
            ;;
        esac

        # --- Применяем variant удаления к базовому списку ---
        for pkg in $VARIANT_REMOVE; do
          BASE_PKGS=$(echo "$BASE_PKGS" | sed "s/\b$pkg\b//g")
        done

        # --- Обработка exclude_keywords (из UI) ---
        EXCLUDE_INPUT="${{ inputs.exclude_keywords }}"
        if [ -n "$EXCLUDE_INPUT" ]; then
          for WORD in $EXCLUDE_INPUT; do
            echo ">>> Excluding packages matching: $WORD"
            BASE_PKGS=$(echo "$BASE_PKGS" | tr ' ' '\n' | grep -iv "$WORD" | tr '\n' ' ')
          done
        fi

        # --- Финальный список пакетов ---
        # Очищаем лишние пробелы
        FINAL_PKGS=$(echo "$BASE_PKGS $DEVICE_PKGS $VARIANT_ADD $DISABLED_PKGS" | tr -s ' ' | sed 's/^ //; s/ $//')

        echo "=========================================="
        echo ">>> FINAL PACKAGE LIST:"
        echo "$FINAL_PKGS" | tr ' ' '\n' | sort | grep -v '^$'
        echo "=========================================="

        # --- Профиль устройства и запуск make image ---
        case "$DEVICE" in
          nanopi-r5s)   IB_PROFILE="friendlyarm_nanopi-r5s" ;;
          nanopi-r6s)   IB_PROFILE="friendlyarm_nanopi-r6s" ;;
          rb5009)       IB_PROFILE="mikrotik_rb5009" ;;
          slateax)      IB_PROFILE="glinet_gl-axt1800" ;;
          ax59u)        IB_PROFILE="asus_rt-ax59u" ;;
          brume2)       IB_PROFILE="glinet_gl-mt2500" ;;
          *)
            echo ">>> ERROR: Unknown device '$DEVICE', cannot determine IB PROFILE!"
            echo ">>> Run 'make info' in Image Builder to find the correct profile name."
            exit 1
            ;;
        esac
        echo ">>> IB Profile: $IB_PROFILE"

        # Валидация: проверяем что профиль существует в IB
        if ! make info 2>/dev/null | grep -q "$IB_PROFILE"; then
          echo ">>> WARNING: Profile '$IB_PROFILE' not found via 'make info'!"
          echo ">>> Available profiles:"
          make info 2>/dev/null | grep "^[A-Za-z]" | head -20 || true
          echo ">>> Attempting to build anyway..."
        fi

        echo ">>> Building image (profile=$IB_PROFILE, partsize=512M)..."
        # CONFIG_TARGET_ROOTFS_PARTSIZE передаётся как make-переменная (не через .config)
        make image \
          PROFILE="$IB_PROFILE" \
          PACKAGES="$FINAL_PKGS" \
          FILES="$WORKDIR/files" \
          EXTRA_IMAGE_NAME="$VARIANT" \
          CONFIG_TARGET_ROOTFS_PARTSIZE=512 \
          CONFIG_TARGET_IMAGES_GZIP=1 \
          V=s 2>&1 | tee /tmp/imagebuilder.log | tail -50 || {
            echo ">>> Image build FAILED!"
            echo ">>> Last 100 lines of log:"
            tail -100 /tmp/imagebuilder.log
            exit 1
          }

        echo ">>> Image build SUCCESSFUL!"

        # --- Результаты ---
        echo "=========================================="
        echo "       [BUILD RESULTS]"
        echo "=========================================="
        echo "Device  : $DEVICE ($TARGET_NAME)"
        echo "Variant : $VARIANT"
        echo "Source  : $SOURCE_NAME ${{ inputs.branch }}"
        echo "Packages in image: $(echo $FINAL_PKGS | wc -w)"
        echo "Output files:"
        find bin/targets -type f \( -name "*.img.gz" -o -name "*.bin" -o \
             -name "*.ubi" -o -name "*.itb" -o -name "*.manifest" \) | \
          xargs ls -lh 2>/dev/null
        echo "=========================================="

        echo "FILE_DATE=_$(date +"%Y%m%d%H%M")" >> $GITHUB_ENV

    # -------------------------------------------------------------------------
    # 13. Загрузка артефактов
    # -------------------------------------------------------------------------
    - name: Upload Artifacts
      uses: actions/upload-artifact@main
      with:
        name: ${{ inputs.source }}_${{ inputs.branch }}_${{ matrix.variant }}_${{ matrix.target }}_${{ env.FILE_DATE }}
        path: ${{ env.IB_DIR }}/bin/targets

    # -------------------------------------------------------------------------
    # 14. Очистка старых запусков и артефактов
    # -------------------------------------------------------------------------
    - name: Delete old workflow runs
      uses: Mattraks/delete-workflow-runs@v2.0.6
      with:
        retain_days: 10
        keep_minimum_runs: 6

    - name: Delete old artifacts
      uses: c-hive/gha-remove-artifacts@v1
      with:
        age: '10 days'
        skip-recent: 6
