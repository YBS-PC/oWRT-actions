name: Universal WRT Builder

on:
  workflow_dispatch:
    inputs:
      target:
        description: 'Target Device'
        required: true
        default: 'combo'
        type: choice
        options:
          - combo
          - rb5009
          - nanopi-r6s
          - nanopi-r5s
          - slateax
          - ax59u
          - brume2
          - all
      
      source:
        description: 'Source Code'
        required: true
        default: 'openwrt'
        type: choice
        options:
          - immortalwrt
          - openwrt
      
      branch:
        description: 'Branch'
        required: true
        default: 'openwrt-25.12'
        type: choice
        options:
          - master
          - openwrt-24.10
          - openwrt-25.12
      
      variant:
        description: 'Build Variant'
        required: true
        default: 'standard'
        type: choice
        options:
          - standard
          - minimal
          - clear
          - switch
          - crystal_clear
          - passwall
          - v2raya
          - xray
      
      exclude_keywords:
        description: 'Exclude Packages (Space separated keywords)'
        required: false
        default: ''
        type: string
      
      commit_hash:
        description: 'Target Commit Hash (Optional)'
        required: false
        default: ''

env:
  FEEDS_CONF: feeds.conf.default
  CONFIG_FILE: ./config/WRT.config
  # 1. Источники
  DIY_P1_SH: ./sh/WRT-part1.sh
  # 2. Фиксы (между update и install)
  DIY_P2_SH: ./sh/WRT-part2.sh
  # 3. Пакеты и настройка (после install)
  DIY_P3_SH: ./sh/WRT-part3.sh
  # 4. Финальный тюнинг (пустой)
  DIY_P4_SH: ./sh/WRT-part4.sh
  
  UPLOAD_BIN_DIR: true
  UPLOAD_FIRMWARE: false
  TZ: Europe/Moscow

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - id: set-matrix
        run: |
          INPUT_TARGET="${{ inputs.target }}"
          INPUT_VARIANT="${{ inputs.variant }}"
          if [ "$INPUT_TARGET" == "combo" ]; then
            echo ">>> Generating COMBO matrix..."
            json='{"include":[{"target":"nanopi-r6s","variant":"minimal"},{"target":"rb5009","variant":"clear"},{"target":"rb5009","variant":"switch"}]}'
          else
            targets="nanopi-r6s rb5009"
            if [ "$INPUT_TARGET" == "all" ]; then
              selected=$targets
            else
              selected="$INPUT_TARGET"
            fi
            json_parts=""
            for t in $selected; do
              [ -n "$json_parts" ] && json_parts="$json_parts,"
              json_parts="$json_parts{\"target\":\"$t\",\"variant\":\"$INPUT_VARIANT\"}"
            done
            json="{\"include\":[$json_parts]}"
          fi
          echo "=========================================="
          echo "       [SETUP SUMMARY]                    "
          echo "=========================================="
          echo "Mode: $INPUT_TARGET"
          echo "Generated Matrix: $json"
          echo "=========================================="
          echo "matrix<<EOF" >> $GITHUB_OUTPUT
          echo "$json" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  build:
    needs: setup
    runs-on: ubuntu-22.04
    permissions:
      contents: write
      actions: write
    
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.setup.outputs.matrix) }}
    
    name: ${{ inputs.source }} ${{ inputs.branch }} [${{ matrix.variant }}] - ${{ matrix.target }}

    steps:
    - name: Free up disk space
      run: |
        echo ">>> Freeing up disk space"
        echo "Initial space:"
        df -h
        
        echo "--- Removing large directories ---"
        # Удаляем Android SDK, .NET, Haskell, Azure, Java (JVM)
        sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc /opt/hostedtoolcache /usr/lib/jvm
        sudo rm -rf /usr/share/swift /usr/local/.ghcup /usr/local/share/powershell /usr/local/share/chromium
        sudo rm -rf /usr/local/share/boost
        sudo rm -rf "$AGENT_TOOLSDIRECTORY"
        
        echo "--- Removing Docker images (Crucial step!) ---"
        # Это освобождает около 3-4 ГБ
        sudo docker image prune --all --force || true
        
        echo "--- Removing unnecessary packages ---"
        # Удаляем браузеры, базы данных и лишние языки
        sudo apt-get -y purge "azure*" "dotnet*" "ghc*" "llvm*" "mono*" "android*" "google*" "firefox*" "powershell*" "mysql*" "php*" || true
        sudo apt-get autoremove -y
        sudo apt-get clean
        
        echo "Final space:"
        df -h

    - name: Checkout
      uses: actions/checkout@main

    - name: Set permissions
      run: |
        [ -d "./files/usr/bin" ] && find ./files/usr/bin -maxdepth 1 -type f -exec chmod 755 {} + || true
        [ -d "./files/etc/uci-defaults" ] && find ./files/etc/uci-defaults -maxdepth 1 -type f -exec chmod 755 {} + || true
        
        echo "=========================================="
        echo "       [PERMISSIONS SUMMARY]              "
        echo "=========================================="
        echo "Permissions set for ./files/usr/bin and uci-defaults."
        [ -d "./files/usr/bin" ] && ls -l ./files/usr/bin | head -n 5 || echo "No custom bins"
        echo "=========================================="

    - name: Download AdGuardHome
      # Условие: выполнять только если вариант НЕ switch И НЕ clear и НЕ crystal_clear
      if: matrix.variant != 'switch' && matrix.variant != 'clear' && matrix.variant != 'crystal_clear'
      run: |
        # AdGuardHome
        AGH_URL="https://github.com/AdguardTeam/AdGuardHome/releases/latest/download/AdGuardHome_linux_arm64.tar.gz"
        echo ">>> Downloading AdGuardHome from: $AGH_URL"
        curl -L -o AGH.tar.gz "$AGH_URL"
        tar -xzf AGH.tar.gz
        mkdir -p ./files/usr/bin
        cp ./AdGuardHome/AdGuardHome ./files/usr/bin/ && chmod 755 ./files/usr/bin/AdGuardHome
        rm -rf AGH.tar.gz AdGuardHome
        echo "=========================================="
        echo "Files in destination:"
        ls -lh ./files/usr/bin/
        echo "=========================================="
        
    - name: Download Sing-box
      # Sing-box не качаем для чистых сборок И для сборок со своими прокси-ядрами
      if: matrix.variant != 'switch' && matrix.variant != 'clear' && matrix.variant != 'crystal_clear' && matrix.variant != 'passwall' && matrix.variant != 'v2raya' && matrix.variant != 'xray'
      run: |
        SB_URL=$(curl -s https://api.github.com/repos/SagerNet/sing-box/releases/latest | grep "browser_download_url.*linux-arm64.tar.gz" | cut -d '"' -f 4 | head -n 1)
        echo ">>> Downloading sing-box from: $SB_URL"
        curl -L -o sb.tar.gz "$SB_URL"
        tar -xzf sb.tar.gz
        mkdir -p ./files/usr/bin
        cp sing-box-*/sing-box ./files/usr/bin/ && chmod 755 ./files/usr/bin/sing-box
        rm -rf sb.tar.gz sing-box-*
        echo "=========================================="
        echo "Files in destination:"
        ls -lh ./files/usr/bin/
        echo "=========================================="

    - name: Configure Build Variables
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # 1. Настройка URL репозитория и API для поиска тегов
        if [ "${{ inputs.source }}" == "immortalwrt" ]; then
          VAR_REPO_URL="https://github.com/immortalwrt/immortalwrt.git"
          API_REPO="immortalwrt/immortalwrt"
        else
          VAR_REPO_URL="https://github.com/openwrt/openwrt.git"
          # OpenWrt теги смотрим на GitHub, даже если клонируем с их сайта
          API_REPO="openwrt/openwrt"
        fi
        echo "REPO_URL=$VAR_REPO_URL" >> $GITHUB_ENV
        
        # 2. Логика Ветки
        INPUT_BRANCH="${{ inputs.branch }}"
        MANUAL_COMMIT="${{ inputs.commit_hash }}"
        
        VAR_BRANCH="$INPUT_BRANCH"
        VAR_TARGET_RELEASE=""
        VAR_COMMIT_HASH="$MANUAL_COMMIT"

        if [ "$INPUT_BRANCH" == "master" ]; then
            # --- ЛОГИКА ДЛЯ MASTER ---
            if [ "${{ inputs.source }}" == "openwrt" ]; then
                VAR_BRANCH="main"
            fi
            VAR_TARGET_RELEASE="snapshots"
            echo ">>> Master/Main branch selected. Using snapshots."
            
        else
            # --- ЛОГИКА ДЛЯ СТАБИЛЬНЫХ ВЕТОК (АВТО-ПОИСК) ---
            echo ">>> Stable branch selected: $INPUT_BRANCH"
            
            # Если хеш не задан вручную, ищем через API
            if [ -z "$MANUAL_COMMIT" ]; then
                # Формируем префикс тега (например: "openwrt-25.12" -> "v25.12")
                TAG_PREFIX="v${INPUT_BRANCH#openwrt-}"
                
                echo ">>> Searching for latest tag starting with '$TAG_PREFIX' in $API_REPO..."
                
                # Магия jq: фильтруем теги по префиксу и берем первый (самый свежий)
                TAG_JSON=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
                    "https://api.github.com/repos/$API_REPO/tags" | \
                    jq --arg prefix "$TAG_PREFIX" '[.[] | select(.name | startswith($prefix))] | first')
                
                if [ "$TAG_JSON" != "null" ] && [ -n "$TAG_JSON" ]; then
                    TAG_NAME=$(echo "$TAG_JSON" | jq -r '.name')
                    TAG_COMMIT=$(echo "$TAG_JSON" | jq -r '.commit.sha')
                    
                    echo ">>> FOUND TAG: $TAG_NAME"
                    echo ">>> FOUND COMMIT: $TAG_COMMIT"
                    
                    VAR_COMMIT_HASH="$TAG_COMMIT"
                    
                    # Формируем путь релиза (удаляем 'v' из названия тега)
                    CLEAN_VER="${TAG_NAME#v}"
                    VAR_TARGET_RELEASE="releases/$CLEAN_VER"
                    
                    # Специфика ImmortalWrt: если папки релиза нет, используем SNAPSHOT
                    if [ "${{ inputs.source }}" == "immortalwrt" ]; then
                         HTTP_CODE=$(curl -o /dev/null -s -w "%{http_code}\n" "https://downloads.immortalwrt.org/$VAR_TARGET_RELEASE/targets/")
                         if [ "$HTTP_CODE" != "200" ]; then
                             echo ">>> Release folder not found on server. Using SNAPSHOT fallback."
                             VAR_TARGET_RELEASE="releases/${INPUT_BRANCH#openwrt-}-SNAPSHOT"
                         fi
                    fi
                else
                    echo ">>> WARNING: No tag found for $TAG_PREFIX. Using default fallback logic."
                fi
            else
                echo ">>> Manual commit provided ($MANUAL_COMMIT). Skipping auto-search."
            fi
            
            # ФОЛБЭК (Если API не нашел тег или произошла ошибка)
            if [ -z "$VAR_TARGET_RELEASE" ]; then
                if [[ "$INPUT_BRANCH" == *"25.12"* ]]; then
                     VAR_TARGET_RELEASE="releases/25.12.0-rc5"
                elif [[ "$INPUT_BRANCH" == *"24.10"* ]]; then
                     if [ "${{ inputs.source }}" == "immortalwrt" ]; then
                        VAR_TARGET_RELEASE="releases/24.10-SNAPSHOT"
                     else
                        VAR_TARGET_RELEASE="releases/24.10.0"
                     fi
                fi
            fi
        fi
        
        echo "REPO_BRANCH=$VAR_BRANCH" >> $GITHUB_ENV
        echo "TARGET_RELEASE=$VAR_TARGET_RELEASE" >> $GITHUB_ENV
        echo "AUTO_COMMIT_HASH=$VAR_COMMIT_HASH" >> $GITHUB_ENV

        # 3. Устройство
        source ./config/conf/${{ matrix.target }}
        echo "TARGET_NAME=${TARGET_NAME}" >> $GITHUB_ENV
        echo "CURRENT_MATRIX_TARGET=${{ matrix.target }}" >> $GITHUB_ENV
        echo "KERNEL_PATH=${KERNEL_PATH}" >> $GITHUB_ENV
        echo "DEVICE_CONFIG_COMMANDS<<EOF" >> $GITHUB_ENV
        echo "${DEVICE_CONFIG_COMMANDS}" >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV
        
        echo "=========================================="
        echo "       [VARIABLES SUMMARY]                "
        echo "=========================================="
        echo "Source         : ${{ inputs.source }}"
        echo "Branch Input   : $INPUT_BRANCH"
        echo "Real Branch    : $VAR_BRANCH"
        echo "Target Release : $VAR_TARGET_RELEASE"
        echo "Target Commit  : $VAR_COMMIT_HASH"
        echo "=========================================="

    - name: Init Env
      env: { DEBIAN_FRONTEND: noninteractive }
      run: |
        # Обновляем базу пакетов
        sudo -E apt-get -qq update
        
        # Устанавливаем полный список зависимостей
        sudo -E apt-get -qq install \
          $(curl -fsSL https://raw.githubusercontent.com/Gzxhwq/OpenWrt-Actions/main/depends-ubuntu-2204) \
          ack antlr3 asciidoc autoconf automake autopoint binutils bison build-essential \
          bzip2 ccache cmake cpio curl device-tree-compiler ecj fastjar flex gawk gettext \
          gcc-multilib g++-multilib git gperf haveged help2man intltool lib32gcc-s1 \
          libc6-dev-i386 libelf-dev libglib2.0-dev libgmp3-dev libltdl-dev libmpc-dev \
          libmpfr-dev libncurses5-dev libncursesw5 libncursesw5-dev libreadline-dev \
          libssl-dev libtool lrzsz mkisofs msmtp nano ninja-build p7zip p7zip-full \
          patch pkgconf python2.7 python3 python3-pip python3-ply python3-docutils \
          qemu-utils re2c rsync scons squashfs-tools subversion swig texinfo uglifyjs \
          upx-ucl unzip vim wget xmlto xxd zlib1g-dev scdoc \
          aria2 jq rename libfuse-dev python3-setuptools python3-pyelftools
        
        # Настройка времени и рабочей директории
        sudo timedatectl set-timezone "$TZ"
        sudo mkdir -p /workdir && sudo chown $USER:$GROUPS /workdir
        
        echo "=========================================="
        echo "       [ENV INIT SUMMARY]                 "
        echo "=========================================="
        echo "All dependencies installed manually."
        echo "Workdir: /workdir"
        date
        echo "=========================================="

    - name: Clone Source
      working-directory: /workdir
      run: |
        git clone --branch $REPO_BRANCH $REPO_URL openwrt
        cd openwrt
        
        # Используем вычисленный хеш (автоматический или ручной)
        if [ -n "$AUTO_COMMIT_HASH" ]; then
           echo "Checking out specific commit: $AUTO_COMMIT_HASH"
           git checkout "$AUTO_COMMIT_HASH"
           CHECKOUT_MSG="Commit $AUTO_COMMIT_HASH"
        else
           CHECKOUT_MSG="Latest head of $REPO_BRANCH"
        fi
        
        ln -sf /workdir/openwrt $GITHUB_WORKSPACE/openwrt
        
        echo "=========================================="
        echo "       [CLONE SUMMARY]                    "
        echo "=========================================="
        echo "Repo cloned: $REPO_URL"
        echo "Branch: $REPO_BRANCH"
        echo "Status: $CHECKOUT_MSG"
        echo "Current Head:"
        git log -1 --format="%H - %s"
        echo "=========================================="

    - name: Apply custom patches
      run: |
        # Проверяем наличие директории
        PATCH_STATUS="No patches dir"
        if [ -d "patches" ]; then
          # Включаем опцию nullglob, чтобы если файлов нет, цикл не запускался
          shopt -s nullglob
          files=(patches/*.patch)
          
          if [ ${#files[@]} -gt 0 ]; then
            for p in "${files[@]}"; do
              echo "Applying patch: $p"
              patch -p1 -d openwrt < "$p" || { echo "Patch failed!"; exit 1; }
            done
            PATCH_STATUS="Applied ${#files[@]} patches"
          else
            echo "No patches found in patches/ directory."
            PATCH_STATUS="Dir exists but empty"
          fi
        else
          echo "Patches directory not found. Skipping."
        fi
        
        echo "=========================================="
        echo "       [PATCH SUMMARY]                    "
        echo "=========================================="
        echo "Result: $PATCH_STATUS"
        echo "=========================================="

    - name: Update Feeds & Config
      run: |
        cd openwrt
        [ -e $GITHUB_WORKSPACE/$FEEDS_CONF ] && cp $GITHUB_WORKSPACE/$FEEDS_CONF ./feeds.conf.default
        
        export VARIANT="${{ matrix.variant }}"
        export CURRENT_MATRIX_TARGET="${{ matrix.target }}"
        echo ">>> Выбран: Variant=$VARIANT, Target=$CURRENT_MATRIX_TARGET"

        mkdir -p files/etc
        date +'%Y-%m-%d' > files/etc/build_date
        
        # 1. Запуск Part 1 (Добавление репозиториев)
        chmod +x $GITHUB_WORKSPACE/$DIY_P1_SH
        $GITHUB_WORKSPACE/$DIY_P1_SH
        
        VARIANT="${{ matrix.variant }}"
        echo "Variant selected: $VARIANT"
        
        # Добавление фидов в зависимости от варианта
        if [ "$VARIANT" == "passwall" ]; then
            # echo -e "\nsrc-git passwall2 https://github.com/xiaorouji/openwrt-passwall2.git" >> feeds.conf.default
            echo -e "\nsrc-git passwall2 https://github.com/Openwrt-Passwall/openwrt-passwall2.git" >> feeds.conf.default
            # echo -e "\nsrc-git passwall_packages https://github.com/xiaorouji/openwrt-passwall-packages.git;main" >> feeds.conf.default
            echo -e "\nsrc-git passwall_packages https://github.com/Openwrt-Passwall/openwrt-passwall-packages.git;main" >> feeds.conf.default
        elif [ "$VARIANT" == "xray" ]; then
            echo -e "\nsrc-git luciappxray https://github.com/yichya/luci-app-xray.git" >> feeds.conf.default
        fi

        # --- ЗАМЕНА ЗЕРКАЛ (FIX 503 ERROR) Меняем git.openwrt.org на github.com---
        sed -i 's|https://git.openwrt.org/feed/packages.git|https://github.com/openwrt/packages.git|g' feeds.conf.default
        sed -i 's|https://git.openwrt.org/project/luci.git|https://github.com/openwrt/luci.git|g' feeds.conf.default
        sed -i 's|https://git.openwrt.org/feed/routing.git|https://github.com/openwrt/routing.git|g' feeds.conf.default
        sed -i 's|https://git.openwrt.org/feed/telephony.git|https://github.com/openwrt/telephony.git|g' feeds.conf.default
        # -------------------------------------
        
        ./scripts/feeds update -a
        
        # 2. Запуск Part 2 (Фиксы версий и Python - строго между update и install)
        if [ -f "$GITHUB_WORKSPACE/$DIY_P2_SH" ]; then
            chmod +x $GITHUB_WORKSPACE/$DIY_P2_SH
            $GITHUB_WORKSPACE/$DIY_P2_SH
        fi

        ./scripts/feeds install -a
        
        [ -e $GITHUB_WORKSPACE/$CONFIG_FILE ] && cp $GITHUB_WORKSPACE/$CONFIG_FILE ./.config
        [ -e $GITHUB_WORKSPACE/files ] && cp -r $GITHUB_WORKSPACE/files ./
        
        eval "$DEVICE_CONFIG_COMMANDS"
        
        # 3. Запуск Part 3 (Замена пакетов, очистка, клонирование доп. софта)
        # Выполняется ПОСЛЕ install, чтобы перезаписать ссылки
        if [ -f "$GITHUB_WORKSPACE/$DIY_P3_SH" ]; then
            chmod +x $GITHUB_WORKSPACE/$DIY_P3_SH
            $GITHUB_WORKSPACE/$DIY_P3_SH
        fi
        
        # === ОПТИМИЗАЦИЯ РАЗМЕРА СБОРКИ ===
        # Критично для OpenWrt + Passwall
        # echo ">>> Optimizing build config to save disk space..."
        # echo 'CONFIG_CCACHE=n' >> ./.config
        # echo 'CONFIG_KERNEL_DEBUG_INFO=n' >> ./.config
        # echo 'CONFIG_DEBUG_INFO=n' >> ./.config
        # =================================
        
        # --- ФИНАЛЬНАЯ НАСТРОЙКА .CONFIG ---
        
        # ВАЖНОЕ ИСПРАВЛЕНИЕ:
        # Удаляем HomeProxy и Sing-Box только если выбран "тяжелый" вариант (Passwall/Xray/V2rayA).
        if [[ "$VARIANT" == "passwall" || "$VARIANT" == "v2raya" || "$VARIANT" == "xray" ]]; then
            echo ">>> Removing HomeProxy and Sing-box dependencies for $VARIANT compatibility..."
            sed -i '/homeproxy/d' ./.config
            sed -i '/sing-box/Id' ./.config
        fi
        
        if [ "$VARIANT" == "passwall" ]; then
            # Очищаем любые упоминания shadowsocks перед настройкой, чтобы не было конфликтов
            sed -i '/[Ss][Hh][Aa][Dd][Oo][Ww][Ss][Oo][Cc][Kk][Ss]/d' ./.config
            # N
            echo 'CONFIG_PACKAGE_luci-app-passwall2_INCLUDE_Haproxy=n' >> ./.config
            # echo 'CONFIG_PACKAGE_luci-app-passwall2_INCLUDE_Hysteria=n' >> ./.config
            echo 'CONFIG_PACKAGE_luci-app-passwall2_INCLUDE_NaiveProxy=n' >> ./.config
            echo 'CONFIG_PACKAGE_luci-app-passwall2_INCLUDE_Shadowsocks_Libev_Client=n' >> ./.config
            echo 'CONFIG_PACKAGE_luci-app-passwall2_INCLUDE_Shadowsocks_Libev_Server=n' >> ./.config
            echo 'CONFIG_PACKAGE_luci-app-passwall2_INCLUDE_Shadowsocks_Rust_Client=n' >> ./.config
            echo 'CONFIG_PACKAGE_luci-app-passwall2_INCLUDE_Shadowsocks_Rust_Server=n' >> ./.config
            echo 'CONFIG_PACKAGE_luci-app-passwall2_INCLUDE_ShadowsocksR_Libev_Client=n' >> ./.config
            echo 'CONFIG_PACKAGE_luci-app-passwall2_INCLUDE_ShadowsocksR_Libev_Server=n' >> ./.config
            echo 'CONFIG_PACKAGE_luci-app-passwall2_INCLUDE_Simple_Obfs=n' >> ./.config
            echo 'CONFIG_PACKAGE_luci-app-passwall2_INCLUDE_SingBox=n' >> ./.config
            echo 'CONFIG_PACKAGE_luci-app-passwall2_INCLUDE_tuic_client=n' >> ./.config
            echo 'CONFIG_PACKAGE_luci-app-passwall2_Iptables_Transparent_Proxy=n' >> ./.config
            # Y
            echo 'CONFIG_PACKAGE_luci-app-passwall2=y' >> ./.config
            echo 'CONFIG_PACKAGE_luci-app-passwall2_Nftables_Transparent_Proxy=y' >> ./.config
            echo 'CONFIG_PACKAGE_luci-app-passwall2_INCLUDE_Xray=y' >> ./.config
            echo 'CONFIG_PACKAGE_luci-app-passwall2_INCLUDE_IPv6_Nat=y' >> ./.config
            echo 'CONFIG_PACKAGE_luci-app-passwall2_INCLUDE_V2ray_Plugin=y' >> ./.config
            echo 'CONFIG_PACKAGE_xray-core=y' >> ./.config
            echo 'CONFIG_PACKAGE_geoview=y' >> ./.config
            echo 'CONFIG_PACKAGE_v2ray-plugin=y' >> ./.config
            echo 'CONFIG_PACKAGE_v2ray-geodata=y' >> ./.config
            
        elif [ "$VARIANT" == "v2raya" ]; then
            echo 'CONFIG_PACKAGE_luci-app-v2raya=y' >> ./.config
            echo 'CONFIG_PACKAGE_v2rayA=y' >> ./.config
            echo 'CONFIG_PACKAGE_v2ray-geodata=y' >> ./.config
            echo 'CONFIG_PACKAGE_xray-core=y' >> ./.config
            
        elif [ "$VARIANT" == "xray" ]; then
            echo 'CONFIG_PACKAGE_luci-app-xray=y' >> ./.config
            echo 'CONFIG_PACKAGE_xray-core=y' >> ./.config
            echo 'CONFIG_PACKAGE_v2ray-geodata=y' >> ./.config
            echo 'CONFIG_PACKAGE_geoview=y' >> ./.config
        fi
        
        # 4. Запуск Part 4 (Тюнинг перед defconfig)
        if [ -f "$GITHUB_WORKSPACE/$DIY_P4_SH" ]; then
            chmod +x $GITHUB_WORKSPACE/$DIY_P4_SH
            $GITHUB_WORKSPACE/$DIY_P4_SH
        else
            echo ">>> P4 tweak script not found: $DIY_P4_SH"
        fi

        # =======================================================
        # ЛОГИКА ИСКЛЮЧЕНИЯ ПАКЕТОВ (EXCLUDE KEYWORDS)
        # =======================================================
        EXCLUDE_INPUT="${{ inputs.exclude_keywords }}"
        if [ -n "$EXCLUDE_INPUT" ]; then
            echo ">>> [EXCLUDE] Processing keywords: $EXCLUDE_INPUT"
            for WORD in $EXCLUDE_INPUT; do
                echo "   > Searching for enabled packages containing '$WORD'..."
                # Ищем только включенные (=y) пакеты с этим словом
                grep -i "^CONFIG_PACKAGE_.*${WORD}.*=y" .config | cut -d'=' -f1 | while read -r CONFIG_NAME; do
                    echo "      - Disabling: $CONFIG_NAME"
                    # Жестко отключаем пакет, чтобы он не собрался
                    sed -i "s|^${CONFIG_NAME}=y|# ${CONFIG_NAME} is not set|" .config
                done
            done
            echo ">>> [EXCLUDE] Done."
        fi
        # =======================================================
             
        make defconfig
        
        echo "=========================================="
        echo "       [CONFIG SUMMARY]                   "
        echo "=========================================="
        echo "Variant selected: $VARIANT"
        echo "Checking key packages in .config:"
        # Проверяем наличие ключевых пакетов для уверенности
        grep -E "CONFIG_PACKAGE_(luci-app-homeproxy|sing-box|luci-app-passwall2|luci-app-v2raya|xray-core)=" .config || echo "None found"
        echo "=========================================="

    - name: Kernel Hash
      run: |
        cd openwrt
        # 1. Определяем домен
        if [[ "$REPO_URL" == *"immortalwrt"* ]]; then
            # DOMAIN="downloads.immortalwrt.org"
            DOMAIN="immortalwrt.kyarucloud.moe"
        else
            DOMAIN="downloads.openwrt.org"
        fi
        
        # 2. Формируем основную ссылку
        FULL_URL="https://$DOMAIN/$TARGET_RELEASE/targets/$KERNEL_PATH/kmods/"
        echo ">>> [Primary] Checking Kernel at: $FULL_URL"
        
        # 3. Пробуем получить список (с защитой от 404)
        KERNEL_LIST=$(curl -sf "$FULL_URL" | grep -oE '6\.[0-9]+\.[0-9]+-[0-9]+-[a-f0-9]+' || true)
        
        # 4. Логика FALLBACK (Если по основной ссылке пусто)
        if [ -z "$KERNEL_LIST" ]; then
             echo ">>> Warning: Primary URL failed or empty."
             
             # Если это не master/main
             if [[ "$REPO_BRANCH" != "main" && "$REPO_BRANCH" != "master" ]]; then
                 VERSION_NUM="${REPO_BRANCH#openwrt-}"
                 
                 # Формируем ссылку на SNAPSHOT этой ветки
                 FALLBACK_URL="https://$DOMAIN/releases/${VERSION_NUM}-SNAPSHOT/targets/$KERNEL_PATH/kmods/"
                 
                 echo ">>> [Fallback] Trying Snapshot URL: $FALLBACK_URL"
                 
                 KERNEL_LIST=$(curl -sf "$FALLBACK_URL" | grep -oE '6\.[0-9]+\.[0-9]+-[0-9]+-[a-f0-9]+' || true)
                 
                 if [ -n "$KERNEL_LIST" ]; then
                    FULL_URL="$FALLBACK_URL"
                    echo ">>> [Fallback] Success! Using Snapshot kmods."
                 fi
             fi
        fi

        # 5. Резервная проверка на ядро не 6.x
        if [ -z "$KERNEL_LIST" ]; then
             echo ">>> Warning: Kernel 6.x pattern not found. Trying generic pattern..."
             KERNEL_LIST=$(curl -sf "$FULL_URL" | grep -oE '[0-9]\.[0-9]+\.[0-9]+-[0-9]+-[a-f0-9]+' || true)
        fi

        # 6. Парсинг и выбор последнего хеша
        LATEST_HASH=$(echo "$KERNEL_LIST" | while read -r line; do
            version=$(echo "$line" | cut -d'-' -f1)
            major=$(echo "$version" | cut -d'.' -f1)
            minor=$(echo "$version" | cut -d'.' -f2)
            patch=$(echo "$version" | cut -d'.' -f3)
            printf "%03d%03d%03d %s\n" "$major" "$minor" "$patch" "$line"
        done | sort -r | head -n1 | cut -d' ' -f2 | cut -d'-' -f3)
        
        # 7. ИТОГОВАЯ ПРОВЕРКА И ПРИМЕНЕНИЕ
        if [ -z "$LATEST_HASH" ]; then
            # === ЕСЛИ ХЕШ НЕ НАЙДЕН ===
            echo ">>> WARNING: Failed to retrieve official kernel hash."
            echo ">>> Continuing with LOCAL kernel hash generation (OpenWrt behavior)."
            echo ">>> NOTE: Official kmods from repositories will NOT work with this build."
            LATEST_HASH="LOCAL (Calculated during build)"
            # Мы НЕ выполняем команду sed, оставляя $(MKHASH) md5 в Makefile
        else
            # === ЕСЛИ ХЕШ НАЙДЕН ===
            echo ">>> Found Official Hash: ${LATEST_HASH}"
            echo ">>> Applying hash to kernel-defaults.mk..."
            sed -i "s/\$(MKHASH) md5/echo \"${LATEST_HASH}\"/g" include/kernel-defaults.mk
        fi
        
        echo "=========================================="
        echo "       [KERNEL HASH SUMMARY]              "
        echo "=========================================="
        echo "Download Domain : $DOMAIN"
        echo "Final URL       : $FULL_URL"
        echo "Applied Hash    : $LATEST_HASH"
        echo "=========================================="
    
    - name: Compile
      run: |
        cd openwrt
        echo ">>> Running multi-thread compilation..."
        
        # 1. Попытка многопоточной сборки (быстро)
        if make -j$(expr $(nproc) + 1); then
            echo ">>> Compilation successful!"
        else
            echo ">>> Multi-thread compilation failed."
            echo ">>> Retrying with single-thread to catch the error (logging to file)..."
            
            # 2. Попытка однопоточной сборки с записью в файл build.log
            # Мы НЕ выводим это на экран, чтобы не переполнить лог GitHub
            make -j1 V=s > build.log 2>&1 || {
                echo ">>> Single-thread compilation failed!"
                echo ">>> Showing last 200 lines of build.log:"
                echo "========================================="
                tail -n 200 build.log
                echo "========================================="
                # Сохраняем лог как артефакт, чтобы можно было скачать, если 200 строк мало
                # (Хак: перемещаем его в bin, чтобы он попал в Upload)
                mkdir -p bin
                cp build.log bin/build_failure.log
                exit 1
            }
        fi
        
        echo "FILE_DATE=_$(date +"%Y%m%d%H%M")" >> $GITHUB_ENV
        
        echo "=========================================="
        echo "       [COMPILE SUMMARY]                  "
        echo "=========================================="
        echo "Compilation finished successfully."
        echo "Firmware Date: $(date +"%Y%m%d%H%M")"
        echo "=========================================="

    - name: Save Bootloader files (Deep Search)
      run: |
        cd openwrt
        mkdir -p bin/u-boot-files
        
        echo ">>> Starting deep search for Bootloader binaries..."
        
        # 1. Прямой поиск специфичных файлов для Rockchip (R5S, R6S)
        # Мы ищем прямо в папке, где они компилировались (build_dir)
        find build_dir/target-* -name "idbloader.img" -type f -exec cp -vf {} bin/u-boot-files/ \;
        find build_dir/target-* -name "u-boot.itb" -type f -exec cp -vf {} bin/u-boot-files/ \;
        
        # 2. Прямой поиск для MediaTek (Filogic/SlateAX/AX59U)
        # Обычно это файлы с расширением .fip или .bin внутри папки u-boot
        find build_dir/target-* -name "*.fip" -type f -exec cp -vf {} bin/u-boot-files/ \;
        find build_dir/target-* -name "u-boot.bin" -type f -path "*/u-boot-*" -exec cp -vf {} bin/u-boot-files/ \;

        # 3. Дополнительный поиск, если файлы уже переименованы системой
        # Ищем в папке bin/targets, исключая пакеты (.apk/.ipk)
        find bin/targets -type f -name "*idbloader.img" -exec cp -vf {} bin/u-boot-files/ \;
        find bin/targets -type f -name "*u-boot.itb" -exec cp -vf {} bin/u-boot-files/ \;
        find bin/targets -type f -name "u-boot.elf" -exec cp -vf {} bin/u-boot-files/ \;
        
        echo ">>> ------------------------------------------------"
        echo ">>> SAVED BOOTLOADER FILES:"
        ls -lh bin/u-boot-files/
        echo ">>> ------------------------------------------------"
    
    - name: Upload
      uses: actions/upload-artifact@main
      with:
        name: ${{ inputs.source }}_${{ inputs.branch }}_${{ matrix.variant }}_${{ matrix.target }}_${{ env.FILE_DATE }}
        path: openwrt/bin

    - name: Delete workflow runs
      uses: Mattraks/delete-workflow-runs@v2.0.6
      with:
        retain_days: 10
        keep_minimum_runs: 6

    - name: Delete old artifacts
      uses: c-hive/gha-remove-artifacts@v1
      with:
        age: '10 days'
        skip-recent: 6
